/**
* Copyright (c) 2011 Aldebaran Robotics. All Rights Reserved
*
* \file movehead.cpp
* \brief Move NAO's head.
*
* A simple example showing how to move NAO's head by using ALMotionProxy.
* This example will make NAO turn its head left and right slowly.
* We use here a specialized proxy to ALMotion.
*/
#include <alvalue/alvalue.h>
#include <alcommon/alproxy.h>
#include <alcommon/albroker.h>
#include <alvision/alimage.h>
#include <alvision/alvisiondefinitions.h>
#include <althread/alcriticalsection.h>
#include <boost/shared_ptr.hpp>
#include <alproxies/alvideodeviceproxy.h>
#include <alproxies/almemoryproxy.h>
#include <alproxies/almotionproxy.h>
#include <althread/almutex.h>
#include <alproxies/altexttospeechproxy.h>
#include <althread/almutex.h>
#include <alerror/alerror.h>

#include <opencv/cv.h>
#include <opencv/highgui.h>
#include "opencv2/opencv.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"


#include <qi/log.hpp>

////
#include <iostream>
#include <alerror/alerror.h>
#include <alproxies/almemoryproxy.h>
#include <alproxies/almotionproxy.h>
#include <alproxies/alrobotpostureproxy.h>
#include <alproxies/altexttospeechproxy.h>
#include <alproxies/alredballdetectionproxy.h>


#include <alproxies/alvisualcompassproxy.h>

#include <alproxies/alvideodeviceproxy.h>
#include <alvision/alvisiondefinitions.h>
#include <alvision/alimage.h>



#include <alproxies/allandmarkdetectionproxy.h>

#include <almath/types/altransform.h>

#include <stdio.h>
#include <math.h>
#include <string>

#include <cmath>
#include<vector>

using namespace AL::Math;
using namespace std;
using namespace AL;
using namespace cv;

#define pi 3.1415926
#define dx 0.20  //击球距离
float dis_move;
namespace
{
    // windows and trackbars name
    const std::string windowName = "GREEN";
	const std::string cannyThresholdTrackbarName = "Canny threshold";
    const std::string accumulatorThresholdTrackbarName = "Accumulator Threshold";
    const std::string usage = "Usage : tutorial_HoughCircle_Demo <path_to_input_image>\n";
    const std::string window_name = "BLUE ";
    const std::string window_red = "RED";
    // initial and max values of the parameters of interests.
    const int cannyThresholdInitialValue = 200;
    const int accumulatorThresholdInitialValue = 16;
    const int maxAccumulatorThreshold = 200;
    const int maxCannyThreshold = 255;
	
}
//Global variable for hsv color wheel plot
int max_hue_range = 179;
int max_step = 3; //nuber of pixel for each hue color
int wheel_width = max_hue_range*max_step;
int wheel_hight = 50;
int wheel_x = 50; //x-position of wheel
int wheel_y = 5;//y-position of wheel
Mat HSV;
#define HUEMAX 179
#define SATMAX 255
#define VALMAX 255
int MAX_H = 179;
int MAX_S = 255;
int MAX_V = 255;
int mouse_x = 0;
//Global variable plot for satuarion-value plot
int S_V_Width = MAX_S;
int S_V_Height = MAX_S;
int S_V_x = 10;
int S_V_y = wheel_y + wheel_hight + 20;
//Global variable for HSV ploat
int HSV_Width = 150;
int HSV_Height = 150;
int HSV_x = S_V_x + S_V_Width + 30;
int HSV_y = S_V_y + 50;
void onTrackbar_changed(int, void*){
 //Plot color wheel.
 int hue_range = 0;
 int step = 1;
 for (int i = wheel_y; i < wheel_hight + wheel_y; i++){
  hue_range = 0;
  for (int j = wheel_x; j < wheel_width + wheel_x; j++){
   if (hue_range >= max_hue_range) hue_range = 0;
   if (step++ == max_step){
    hue_range++;
    step = 1;
   }
Vec3b pix;
   pix.val[0] = hue_range;
   pix.val[1] = 255;
   pix.val[2] = 255;

   //HSV.at<Vec3b>(i, j) = pix;
  }
 }
}

/****检测红球*****/
void redball_detect(const std::string& robotIP, float allballdata[6])
{
      AL::ALVideoDeviceProxy camProxy(robotIP, 9559);
      AL::ALMotionProxy motionProxy(robotIP, 9559);
	  AL::ALTextToSpeechProxy fTtsProxy(robotIP, 9559);

//use to test
	   std::string names  = "Head";
    float stiffnessLists  = 1.0f;
    float timeLists  = 1.0f;
    motionProxy.stiffnessInterpolation(names, stiffnessLists, timeLists); 

 Mat src, src_gray, frameHSV, channel[3], frameHSV_BW, channel_HSV[3];
 Mat pass[3];
 Mat frame, frameCopy, image;
	 int cameraId = 1;//0上，1下
	 camProxy.setActiveCamera(cameraId);
	 std::string clientName = camProxy.subscribe("test", kVGA, kBGRColorSpace, 5);//fps=5

	 cv::Mat imgHeader = cv::Mat(cv::Size(640, 480),CV_8UC3); 
	  std::vector<float>result = motionProxy.getPosition("CameraBottom",2,true);//bottom
	  float CameraHeight = result.at(2);

 int Hm = 7;
 int Sm = 20;
 int Vm = 255;
 int R = 0;
 int G = 0;
 int B = 0;
 int HM = 14;
 int SM = 255;
 int VM = 255;

 //declare and initialize both parameters that are subjects to change
 int cannyThreshold = cannyThresholdInitialValue;
 int accumulatorThreshold = accumulatorThresholdInitialValue;
 // create the main window, and attach the trackbars
 namedWindow(windowName, WINDOW_AUTOSIZE);
 createTrackbar(cannyThresholdTrackbarName, windowName, &cannyThreshold, maxCannyThreshold);
 createTrackbar(accumulatorThresholdTrackbarName, windowName, &accumulatorThreshold, maxAccumulatorThreshold);
 namedWindow(window_name);
 createTrackbar("Hue Min", window_name, &Hm, HUEMAX, onTrackbar_changed);
 HSV.create(640, 480, CV_8UC3); //Mat to store clock image
 HSV.setTo(Scalar(200, 0, 200));
 onTrackbar_changed(0, 0); //initialoze window
 
 int redballFlag = 0;//检测到红球标志
 int   loseBallTimes = 0;
 float d1_a=0;
float d2_a=0;
float d1=0;
float d2=0;
float Xw2=0;
float Yw2=0;

 while (redballFlag == 0)
  {	  
	  std::vector<float> Rotation1 = motionProxy.getAngles("HeadPitch", true);
	  float pitch=Rotation1.at(0);
	   std::vector<float> Rotation2 = motionProxy.getAngles("HeadYaw", true);
	  float yaw=Rotation2.at(0);

    ALValue img = camProxy.getImageRemote(clientName);
    imgHeader.data = (uchar*)img[6].GetBinary();   
    Mat frame = imgHeader.clone();  
 
  
   //split the channels in order to manipulate them
   split(frame, channel);
   //threshold(channel[2], channel[2], 130, 255, 0);
   
   //To get the RED only
   channel[0] = channel[0].mul(.1*Hm); //B
   channel[1] = channel[1].mul(.1*Hm);//G
   channel[2] = channel[2] - channel[0] - channel[1]; //R

   double minVal, maxVal;
  // int x, y;
   minMaxLoc(channel[0], &minVal, &maxVal);
   for (int i = 0; i < channel[1].cols; i++)
   {
    for (int j = 0; j < channel[1].rows; j++){
     if (channel[2].at<unsigned char>(j, i)  < 0)
      channel[2].at<unsigned char>(j, i) = 0;
    }
   }
 

  
    cannyThreshold = std::max(cannyThreshold, 1);
   accumulatorThreshold = std::max(accumulatorThreshold, 1);
        std::vector<Vec3f> circles;
        // runs the actual detection
        HoughCircles( channel[2], circles, CV_HOUGH_GRADIENT, 1, frame.rows/8, cannyThreshold, accumulatorThreshold, 0, 0 );


     redballFlag = circles.size();//检测到红球标志
     for( size_t i = 0; i < circles.size(); i++ )
        {
            Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
            int radius = cvRound(circles[i][2]);
            circle( frame, center, 3, Scalar(0,255,0), -1, 8, 0 );
            circle( frame, center, radius, Scalar(0,0,255), 3, 8, 0 );
			//std::cout<<"圆心X="<<circles[i][0]<<std::endl;
			//std::cout<<"圆心Y="<<circles[i][1]<<std::endl;
			 float m_center_x= circles[i][0];
	         float m_center_y= circles[i][1];
      float redballradius=0.02f;

	//方法2,无需内参，考虑了转头（上下左右）
	float d1_a=(m_center_y-240.0f)*47.64f/480.0f*0.01744f;
	float d1=(CameraHeight-redballradius)/tan(0.6929f+pitch+d1_a);//对比
	float d2_a=(320.0f-m_center_x)*60.92f/640.0f*0.01744f;
	float d2=d1/cos(d2_a);
	float Xw2=d2*cos(d2_a+yaw);
	float Yw2=d2*sin(d2_a+yaw);
	float Zw=redballradius=0.02f;
    float dis_move=sqrt( Xw2*Xw2 + Yw2*Yw2);
	          
        }
      
        //imshow("原图" , frame);
	}
    
    allballdata[0] = d1_a; //centerX
	allballdata[1] = d2_a; //centerY
	allballdata[2] = Xw2;  //distance in X axis of robot
	allballdata[3] = Yw2;  //distance in Y axis of robot
	allballdata[4] = CameraHeight;
	allballdata[5] = redballFlag;

	std::cout<<"centerX: "<<d1_a<<std::endl;
	std::cout<<"centerY: "<<d2_a<<std::endl;
	std::cout<<"Xw2: "<<Xw2<<std::endl;
	std::cout<<"Yw2: "<<Yw2<<std::endl;
	std::cout<<"相机高度: "<<CameraHeight<<std::endl;
	std::cout<<"redBallDetected?："<<redballFlag<<std::endl;

}



/********************寻找红球*****************************/
void redball_Search(const std::string& robotIP)
{
	AL::ALMotionProxy motionProxy(robotIP,9559);
	AL::ALRobotPostureProxy postureProxy(robotIP, 9559);
	AL::ALMemoryProxy memoryProxy(robotIP, 9559);
	AL::ALRedBallDetectionProxy redballProxy(robotIP, 9559);
	AL::ALVideoDeviceProxy cameraProxy(robotIP, 9559);
	AL::ALTextToSpeechProxy tts(robotIP, 9559);

//头部位置初始化
	float maxSpeed1 = 0.3f; // Using 30% of maximum joint speed, Pitch
	float maxSpeed2 = 0.2f; // Using 50% of maximum joint speed, Yaw
	motionProxy.angleInterpolationWithSpeed("HeadPitch", 0.00, maxSpeed1);//头下低21.4度:0.373
	motionProxy.angleInterpolationWithSpeed("HeadYaw", 0.00, maxSpeed2);
	
//#移动后进行全面搜索
	float wzCamera1 = 0, wzCamera2 = 0, wzCamera3 = 0;
	float wyCamera1 = 0, wyCamera2 = 0, wyCamera3 = 0;
	//float angularSize1 = 0, angularSize2 = 0, angularSize3 = 0;
	float head_yaw1 =0, head_yaw2 =0, head_yaw3 =0;
	int redball_flag1 = 0, redball_flag2 = 0, redball_flag3 = 0;
    //步态设置
    AL::ALValue one  = AL::ALValue::array("MaxStepX", 0.02); //0.001~0.080, Default:0.040,地面越硬数值越大
	AL::ALValue two  = AL::ALValue::array("MaxStepY", 0.1); //0.101~0.160, Default:0.140
	AL::ALValue three= AL::ALValue::array("MaxStepTheta", 0.4); //0.001~0.524, Default:0.349
	AL::ALValue four = AL::ALValue::array("MaxStepFrequency", 0.3);//0~1, Default:1
    AL::ALValue five = AL::ALValue::array("StepHeight",0.020); //0.005~0.040, Default:0.020
	AL::ALValue six  = AL::ALValue::array("TorsoWx",0.00); //-0.122~0.122, Default:0.000
	
	AL::ALValue moveConfig=AL::ALValue::array(one,two,three,four,five,six);
    //////
    motionProxy.moveTo(0.2, 0.0, 0.0, moveConfig);  //移动20cm后开始找红球，可以不走  
    Sleep(2000);
	//motionProxy.angleInterpolationWithSpeed("HeadPitch", 0.00, maxSpeed1);//头下低21.4度:0.373
	//motionProxy.angleInterpolationWithSpeed("HeadYaw", 0.00, maxSpeed2);
	//Sleep(2000);

	float *allballdata = new float[6];//动态分配内存，方6个数据
	float ball_Data[6] = {0};//存放动态内存数据的数组
//向前搜索
    for(int i=0; i<2; i++)
	{
		redball_detect(robotIP, allballdata);
		wzCamera1 = allballdata[0];
		wyCamera1 = allballdata[1];
		redball_flag1 = allballdata[5];
		head_yaw1 = 0.00;
			
	}
	std::cout<< "以上为前面数据"<<std::endl;
				std::cout<< "wzCamera1: "<<wzCamera1<<std::endl;
				std::cout<< "wyCamera1: "<<wyCamera1<<std::endl;
				std::cout<< "redball_flag1: "<<redball_flag1<<std::endl;
				std::cout<< "head_yaw1: "<<head_yaw1<<std::endl;
//向左搜索     
    //#showNaoImage()
    //#motionProxy.moveTo(0.0,0.0,60*math.pi/180)
    motionProxy.angleInterpolationWithSpeed("HeadPitch", 0.00, maxSpeed1);//头下低21.4度:0.373
	motionProxy.angleInterpolationWithSpeed("HeadYaw", 0.785, maxSpeed2);
    Sleep(4000);
    for(int i=0; i<2; i++)
	{
	    redball_detect(robotIP, allballdata);
		wzCamera2 = allballdata[0];
		wyCamera2 = allballdata[1];
		redball_flag2 = allballdata[5];
		head_yaw2 = 0.785;
	}	
	std::cout<< "以上为左边数据"<<std::endl;
		std::cout<< "wzCamera2: "<<wzCamera2<<std::endl;
		std::cout<< "wyCamera2: "<<wyCamera2<<std::endl;
		std::cout<< "redball_flag2: "<<redball_flag2<<std::endl;
		std::cout<< "head_yaw2: "<<head_yaw2<<std::endl;
//向右搜索		
    //#showNaoImage()
    motionProxy.angleInterpolationWithSpeed("HeadPitch", 0.00, maxSpeed1);//头下低21.4度:0.373
	motionProxy.angleInterpolationWithSpeed("HeadYaw", -0.785, maxSpeed2);
    Sleep(4000);
    for(int i=0; i<2; i++)
	{
	    redball_detect(robotIP, allballdata);
		wzCamera3 = allballdata[0];
		wyCamera3 = allballdata[1];
		redball_flag3 = allballdata[5];
		head_yaw3 = -0.785;
	}
	std::cout<< "以上为右边数据"<<std::endl;
		std::cout<< "wzCamera3: "<<wzCamera3<<std::endl;
		std::cout<< "wyCamera3: "<<wyCamera3<<std::endl;
		std::cout<< "redball_flag3: "<<redball_flag3<<std::endl;
		std::cout<< "head_yaw3: "<<head_yaw3<<std::endl;
        
    //#showNaoImage()
    //#判断球的位置
	float redballFlag = 0; //红球标志寄存器：1代表检测到，0代表不在视野范围内
    if (redball_flag1)
	{
	    tts.say("redball is in front !");  //#前面
        redballFlag = 1;               	
	}

      
    if (redball_flag2)
	{
	    tts.say("redball is on the left !");  //#左边
        redballFlag = 1;       	
	}


    if (redball_flag3)
	{
	    tts.say("redball is on the right !");  //#右边
        redballFlag = 1;        
	} 

    if (!(redball_flag1 && redball_flag2 && redball_flag3))
	{
	   tts.say("where is red ball ?");  //#没有球
        redballFlag = 0;
        motionProxy.angleInterpolationWithSpeed("HeadYaw", 0.0, 0.5);
        motionProxy.setMoveArmsEnabled(false, false);
        motionProxy.moveTo(0.2,0.0,0.0, moveConfig);   //#寻找距离修正
        
	}

}   /********************寻找红球*****************************/

/************计算与红球距离并移动到redball************/
void Move_to_redball(const std::string& robotIP, float headyaw, float alpha)
{
	AL::ALMemoryProxy memoryProxy(robotIP, 9559);
	AL::ALMotionProxy motionProxy(robotIP,9559);
	AL::ALVisualCompassProxy compassProxy(robotIP,9559);

    float h = 0.48; //低头21.4度时摄像头高度，0.48头抬正时摄像头高度
   
	AL::ALValue one  = AL::ALValue::array("MaxStepX", 0.02); //0.001~0.080, Default:0.040,地面越硬数值越大
	AL::ALValue two  = AL::ALValue::array("MaxStepY", 0.1); //0.101~0.160, Default:0.140
	AL::ALValue three= AL::ALValue::array("MaxStepTheta", 0.4); //0.001~0.524, Default:0.349
	AL::ALValue four = AL::ALValue::array("MaxStepFrequency", 0.3);//0~1, Default:1
    AL::ALValue five = AL::ALValue::array("StepHeight",0.020); //0.005~0.040, Default:0.020
	AL::ALValue six  = AL::ALValue::array("TorsoWx",0.00); //-0.122~0.122, Default:0.000
	
	AL::ALValue moveConfig=AL::ALValue::array(one,two,three,four,five,six);

    

	//#接下来，第一次，机器人转到正对红球的方向
    motionProxy.setMoveArmsEnabled(false, false);
    motionProxy.angleInterpolationWithSpeed("HeadYaw", 0.0, 0.5);
	motionProxy.angleInterpolationWithSpeed("HeadPitch",0.00, 0.35f);//保持低头21.4度:0.373
	motionProxy.moveTo(0, 0, -0.785, moveConfig);
    //motionProxy.moveTo(x, y, theta, moveConfig);
    motionProxy.setMoveArmsEnabled(true, false);
    //#接下来，第二次，机器人走到距离红球30厘米的位置
	//motionProxy.moveTo(x, y, theta, moveConfig);
    motionProxy.moveTo(40, 0, 0, moveConfig);
	 Sleep(1500);
	motionProxy.moveTo(10, 0, 0, moveConfig);
	motionProxy.moveTo(0, 0, 1.57, moveConfig);//向左转90度

	 motionProxy.moveTo(0.4, 0, 0, moveConfig);
	  motionProxy.moveTo(0, 0, -1.57,moveConfig);
	   motionProxy.moveTo(0.4, 0, 0, moveConfig);

}
int main(int argc, char* argv[]) {

  /*if(argc != 2)
  {
    std::cerr << "Wrong number of arguments!" << std::endl;
    std::cerr << "Usage: movehead NAO_IP" << std::endl;
    exit(2);
  }*/

	const std::string robotIP = "192.168.1.103";


	//initialize object
	AL::ALMemoryProxy memoryProxy(robotIP, 9559);     //  memory  object
    AL::ALMotionProxy motionProxy(robotIP, 9559);     //  motion  object
	AL::ALRobotPostureProxy postureProxy(robotIP, 9559);
	AL::ALTextToSpeechProxy tts(robotIP, 9559);
	AL::ALRedBallDetectionProxy redballProxy(robotIP, 9559);
	AL::ALVideoDeviceProxy cameraProxy(robotIP, 9559);
	AL::ALLandMarkDetectionProxy landmarkProxy(robotIP, 9559);


	//步态设置
    AL::ALValue one  = AL::ALValue::array("MaxStepX", 0.02); //0.001~0.080, Default:0.040,地面越硬数值越大
	AL::ALValue two  = AL::ALValue::array("MaxStepY", 0.1); //0.101~0.160, Default:0.140
	AL::ALValue three= AL::ALValue::array("MaxStepTheta", 0.4); //0.001~0.524, Default:0.349
	AL::ALValue four = AL::ALValue::array("MaxStepFrequency", 0.3);//0~1, Default:1
    AL::ALValue five = AL::ALValue::array("StepHeight",0.020); //0.005~0.040, Default:0.020
	AL::ALValue six  = AL::ALValue::array("TorsoWx",0.00); //-0.122~0.122, Default:0.000
	
	AL::ALValue moveConfig=AL::ALValue::array(one,two,three,four,five,six);
///////////////////////////////////


  /** The name of the joint to be moved. */
  //const AL::ALValue jointName = "HeadYaw";


  try {
    /** Create a ALMotionProxy to call the methods to move NAO's head.
    * Arguments for the constructor are:
    * - IP adress of the robot
    * - port on which NAOqi is listening, by default 9559
    */

	  //wake up robot,单独调试完删除
	//motionProxy.moveInit();
	motionProxy.wakeUp();
	postureProxy.goToPosture("StandInit", 0.5);
	motionProxy.moveTo(0.2, 0, 0, moveConfig);
	Sleep(4000);
	//头部位置初始化
	float maxSpeed1 = 0.3f; // Using 30% of maximum joint speed, Pitch
	float maxSpeed2 = 0.2f; // Using 50% of maximum joint speed, Yaw
	motionProxy.angleInterpolationWithSpeed("HeadPitch", 0.00, maxSpeed1);//头下低21.4度:0.373
	motionProxy.angleInterpolationWithSpeed("HeadYaw", 0.00, maxSpeed2);
	//往左边看
	Sleep(4000);
	motionProxy.angleInterpolationWithSpeed("HeadPitch", 0.00, maxSpeed1);//头下低21.4度:0.373
	motionProxy.angleInterpolationWithSpeed("HeadYaw", 0.785, maxSpeed2);
	//往右边看
	Sleep(4000);
	motionProxy.angleInterpolationWithSpeed("HeadPitch", 0.00, maxSpeed1);//头下低21.4度:0.373
	motionProxy.angleInterpolationWithSpeed("HeadYaw", -0.785, maxSpeed2);
	Sleep(4000);
	motionProxy.angleInterpolationWithSpeed("HeadPitch", 0.00, maxSpeed1);//头下低21.4度:0.373
	motionProxy.angleInterpolationWithSpeed("HeadYaw", 0.00, maxSpeed2);

	Sleep(4000);

	tts.say("redball is on the right !"); 

	motionProxy.moveTo(0, 0, -0.52, moveConfig);

    //#接下来，第二次，机器人走到距离红球30厘米的位置
	//motionProxy.moveTo(x, y, theta, moveConfig);
    motionProxy.moveTo(0.4, 0, 0, moveConfig);
	 Sleep(3000);
	motionProxy.moveTo(0.1, 0, 0, moveConfig);
	motionProxy.moveTo(0, 0, 1.57, moveConfig);//向左转90度

	 motionProxy.moveTo(0.5, 0, 0, moveConfig);
	  motionProxy.moveTo(0, 0, -1.57,moveConfig);
	   motionProxy.moveTo(0.5, 0, 0, moveConfig);
    }



  catch (const AL::ALError& e) {
   std::cerr << "Caught exception: " << e.what() << std::endl;
    exit(1);
  }
  exit(0);
}
